## 文档同步准则 (Document Synchronization Standard)

1.  **实现蓝图 (Implementation Blueprint):** 本文档旨在清晰地描述各代码模块的功能以及它们如何协同工作。
2.  **模型驱动 (Model-Driven):** 本文档的内容必须严格依据当前核心物理模型（Cosserat Rod Theory）。当核心模型更新后，应立即检查并同步更新本文档中受影响的部分。
3.  **保持通俗 (Maintain Clarity):** 本文档的描述应尽量保持通俗易懂，侧重于“怎么做”而非“为什么”。

---

# 项目核心系统说明书 (V7.0 - Cosserat 物理引擎)

本文档旨在用通俗易懂的方式，梳理本项目的软件实现步骤、模块功能及它们之间的协同工作方式。它更关心“代码是怎么跑的”，而非“理论为什么是对的”。

## 1. 系统总览与核心功能 (System Overview and Core Functionality)

本项目旨在为一款三段式连续体机器人，开发一个基于 **Cosserat 杆理论** 的高保真物理仿真与控制框架。核心功能包括：

*   **机器人建模**: 基于 Cosserat 理论，精确描述机器人的几何、弹性、重力及缆绳驱动特性。
*   **正运动学**: 根据离散化的构型向量 `q`，通过数值积分（RK4）计算机器人末端位姿。
*   **静力学求解 (内循环)**: 在给定电机位移 `Δl_motor` 下，通过能量最小化原理（L-BFGS-B）求解机器人的静态平衡构型 `q_eq`。
*   **逆运动学求解 (外循环)**: 根据目标末端位姿 `T_target`，通过基于解析雅可比的牛顿法，反向求解所需的电机位移 `Δl_motor`。
*   **分析与验证**: 提供多种分析工具（如路径跟踪、工作空间分析）和覆盖全面的验证脚本，确保模型和算法的正确性与性能。

## 2. 核心模块清单 (Code Modules)

*   `config.json`: **[物理蓝图]** 存储所有描述机器人几何、材料（刚度）、质量分布等物理参数。

*   `src/cosserat/kinematics.py`: **[几何学专家]** 负责正运动学。其核心函数 `forward_kinematics` 接收一个构型向量 `q`，通过 **RK4 数值积分** Cosserat 杆方程，计算出机器人各段精确的空间位姿 `T`。

*   `src/cosserat/statics.py`: **[物理学专家]** 负责静力学建模。它定义了系统的**总势能 `U_total = U_elastic + U_gravity + U_cable`** 及其**梯度 `∇U_total`**。所有能量的计算都依赖于 `kinematics.py` 提供的几何信息。它是连接运动学和静态平衡的桥梁。

*   `src/cosserat/solver.py`: **[内循环求解器]** 封装了 `scipy.optimize.minimize` (L-BFGS-B)。它的核心任务是：接收一个电机位移 `Δl_motor`，调用 `statics.py` 计算能量和梯度，寻找并返回能让系统总势能最小的那个平衡构型 `q_eq`。

*   `src/cosserat/outer_solver.py`: **[外循环总指挥]** 这是逆运动学的顶层接口。它通过迭代调整电机位移 `Δl_motor` 来最小化末端位姿误差。在每次迭代中，它会调用**内循环求解器**来获得当前位姿，并使用基于隐函数定理推导出的**解析任务雅可比 `J_task`** 来高效地确定下一步的调整方向。

*   `analysis/`: **[分析脚本目录]** 存放所有用于性能分析的脚本，如 `path_tracking.py` 和 `workspace_analysis.py`。

## 3. 核心工作流程 (V7.0 - 嵌套优化)

逆运动学求解（从目标位姿 `T_target` 求解电机位移 `Δl_motor`）的核心，是通过一套**嵌套优化**流程来实现的。这套流程确保了求解的效率和精度。

### **核心思想：基于能量最小化的嵌套优化**

在深入了解工作流程前，理解其核心思想至关重要。系统的静态平衡状态可以通过两种等效的方式描述：
1.  **强形式 (力/力矩平衡)**: 机器人内部各点的力和力矩处处为零。这由一组复杂的微分方程描述，直接求解在数值上非常困难。
2.  **弱形式 (能量最低)**: 机器人处于总势能 `U_total` 的局部最小值点。这意味着势能对所有构型变量的梯度 `∇U` 为零。

本项目选择**能量最低**原理作为求解框架。这并非否定了力平衡，恰恰相反，`∇U = 0` 的状态**就是**力与力矩平衡的状态。我们采用此方法，是因为可以将复杂的微分方程求解问题，转化为一个标准的、更稳健的**数值优化问题**，从而利用 `scipy` 等成熟的优化库高效求解。

因此，整个系统的核心，就是一套基于“能量最低”原理的**嵌套优化**流程。

以下是调用一次 `outer_solver.py` 中的 `solve_ik_globally` 后，内部发生的故事：

### **外循环: 寻找正确的电机位移 (在 `outer_solver.py` 中)**

1.  **接收任务**: `solve_ik_globally` 函数接收到一个目标位姿 `T_target` 和一个初始的电机位移猜测 `Δl_guess`。
2.  **启动迭代**: 进入一个牛顿法迭代循环，目标是找到一组电机位移 `Δl_motor`，使其对应的机器人末端位姿与 `T_target` 一致。
3.  **评估当前位姿 (调用内循环)**: 在每次迭代中，为了知道当前的 `Δl_motor` 会让机器人处于什么姿态，它会调用**内循环求解器** `solver.solve_static_equilibrium(Δl_motor)`。
4.  **内循环的黑箱**: 外循环不关心内循环的细节，它只是等待 `solver.py` 返回一个计算出的平衡构型 `q_eq`。
5.  **计算误差**: 拿到 `q_eq` 后，外循环调用 `kinematics.py` 计算出对应的末端位姿 `T_current`，并计算其与 `T_target` 之间的 6D 误差向量 `e`。
6.  **计算下一步方向**: 外循环计算**解析任务雅可比 `J_task`**，它描述了末端位姿 `T` 对电机位移 `Δl_motor` 的敏感度。然后通过求解线性方程 `J_task * Δ(Δl) = e` 来计算出电机位移的修正量 `Δ(Δl)`。
7.  **更新并重复**: 更新电机位移 `Δl_motor = Δl_motor - Δ(Δl)`，然后重复步骤 3-7，直到误差 `e` 小于阈值。

### **内循环: 寻找给定驱动下的平衡构型 (在 `solver.py` 中)**

当外循环调用 `solve_static_equilibrium(Δl_motor)` 时，内循环开始工作：

1.  **接收驱动**: 内循环接收到一个固定的电机位移 `Δl_motor`。
2.  **启动能量最小化**: 它的唯一目标是，找到一个构型 `q`，使得机器人在该构型下的总势能 `U_total` 最小。它使用 `L-BFGS-B` 算法来实现这一点。
3.  **迭代评估**: 在 `L-BFGS-B` 的每次迭代中：
    a.  它向 `statics.py` 模块询问：“对于我当前的构型猜测 `q_guess`，系统的总势能和梯度是多少？”
    b.  `statics.py` 模块会先调用 `kinematics.py` 计算出 `q_guess` 对应的精确几何形状，然后基于这个形状计算出 `U_total` 和 `∇U_total`，并返回给内循环。
    c.  `L-BFGS-B` 根据返回的梯度信息，决定下一个更好的构型猜测 `q_guess`。
4.  **找到平衡并返回**: 当梯度 `∇U_total` 足够接近于零时，`L-BFGS-B` 算法收敛。此时的构型 `q` 就是系统在该电机驱动下的**静态平衡构型 `q_eq`**。内循环将这个 `q_eq` 返回给外循环。

## 4. 流程图 (Flowchart)

**主流程：逆运动学求解 (IK Solving)**

```
[开始: T_target, Δl_guess]
  |
  V
[进入 外循环 (outer_solver.py)]
  |
  V
[迭代 (牛顿法)]
  |
  V
  [调用 内循环 solver.solve_static_equilibrium(Δl_motor)]
    |
    V
    [进入 内循环 (solver.py)]
      |
      V
      [迭代 (L-BFGS-B)]
        |
        V
        [调用 statics.py 获取 U_total, ∇U_total]
          |
          V
          [调用 kinematics.py 获取几何信息]
          |
          V
        [返回 U_total, ∇U_total]
        |
        V
      [内循环收敛]
      |
      V
    [返回 平衡构型 q_eq]
    |
    V
  [调用 kinematics.py 计算当前位姿 T_current]
  |
  V
  [计算位姿误差 e = T_current - T_target]
  |
  V
  [计算解析任务雅可比 J_task]
  |
  V
  [计算电机位移修正量 Δ(Δl)]
  |
  V
  [更新 Δl_motor]
  |
  V
[外循环收敛]
  |
  V
[返回 最终电机位移 Δl_motor*]
  |
  V
[结束]
```

## 5. 验证与诊断 (Verification and Diagnosis)

为了确保模型的准确性和算法的鲁棒性，本项目采用了多层次的验证和诊断策略：

*   **单元测试**: 针对 `src/cosserat/` 目录下的各核心模块，编写了详细的单元测试，验证其数学计算的正确性（例如，解析导数与数值导数的对比）。
*   **集成测试**: 通过 `verification/` 目录下的脚本，验证不同模块协同工作时的正确性。
*   **物理场景验证**: 在 `statics.py` 和 `solver.py` 的自检中，包含了对“直立”、“纯弯曲”、“有驱动”等多个物理场景的测试，确保模型行为符合物理直觉。
*   **分析工具**: `analysis/` 目录下的脚本（如 `workspace_analysis.py`）不仅是应用，也是对整个系统端到端性能和鲁棒性的最终检验。

## 6. 边界与风险 (Boundaries and Risks)

*   **模型假设**: Cosserat 模型本身是理想化的，未考虑材料塑性、疲劳等。数值积分（RK4）和优化算法（L-BFGS-B）的精度和收敛性也受限于其内在属性。
*   **数值病态**: 在某些极端构型或参数组合下，可能出现雅可比矩阵病态，导致外循环求解器收敛困难或不稳定。
*   **参数敏感性**: 模型的性能对 `config.json` 中的物理参数（特别是刚度）高度敏感，不准确的参数可能导致仿真结果与物理现实不符。
*   **计算效率**: 嵌套优化虽然在逻辑上清晰，但计算成本较高，对于实时控制可能需要进一步优化（如预计算、模型降阶等）。