## 文档同步准则 (Document Synchronization Standard)

1.  **实现蓝图 (Implementation Blueprint):** 本文档旨在清晰地描述各代码模块的功能以及它们如何协同工作。
2.  **方案驱动 (Design-Driven):** 本文档的内容必须严格依据 `三段式...md` 中的核心方案。当核心方案更新后，应立即检查并同步更新本文档中受影响的部分。
3.  **保持通俗 (Maintain Clarity):** 本文档的描述应尽量保持通俗易懂，侧重于“怎么做”而非“为什么”。

---

# 项目核心系统说明书 (V5.1 - 物理一致性逆解器)

本文档旨在用通俗易懂的方式，梳理本项目的软件实现步骤、模块功能及它们之间的协同工作方式。它更关心“代码是怎么跑的”，而非“理论为什么是对的”。

## 1. 系统总览与核心功能 (System Overview and Core Functionality)

本项目旨在开发一个用于连续体机器人（三段式 PCC 混合结构）的物理一致性逆运动学求解器。核心功能包括：

*   **机器人建模**: 精确描述机器人的几何、弹性、驱动和重力特性。
*   **正运动学**: 根据构型向量计算机器人末端位姿和各段质心。
*   **静力学求解**: 在给定驱动力下，通过能量最小化原理求解机器人的平衡构型。
*   **逆运动学求解**: 根据目标末端位姿，反向求解所需的驱动力。
*   **无量纲化**: 将物理量映射到尺度健康的数学域，提高优化算法的稳定性和收敛速度。
*   **多起点全局搜索**: 通过在驱动力可行域内随机生成初始猜测，提高逆运动学求解的全局最优性。
*   **分析与验证**: 提供多种分析工具（如路径跟踪、工作空间分析、敏感性分析）和验证脚本，确保模型和算法的正确性与性能。

## 2. 核心模块清单 (Code Modules)

*   `config.json`: **[物理蓝图]** 存储所有描述机器人“长什么样”、“有多硬”、“有多重”的物理参数（单位：mm, kg, N等）。

*   `kinematics.py`: **[几何学专家]** 负责正运动学。接收一个**物理**构型 `q`，计算出对应的**物理**末端位姿 `T`、各段质心、以及所有相关的**解析雅可比矩阵** (`J_kin`, `J_com`)。

*   `statics.py`: **[物理学专家]** 负责静力学。接收**物理**构型 `q` 和**物理**驱动力 `τ`，计算系统的总势能 `U_total` 及所有相关的**全套解析导数**，包括梯度 `∇U`、海森矩阵 `H` 和驱动雅可比 `C`。

*   `solver.py`: **[内循环求解器]** 封装了 `scipy.optimize.minimize` (L-BFGS-B)。它的任务是：接收一个**物理**驱动力 `τ`，寻找并返回能让系统总势能最小的那个**物理**平衡构型 `q`。

*   `nondimensionalizer.py`: **[专业翻译官]** 负责在“物理世界”和“数学世界”之间进行双向翻译。它将带单位的物理量（如米, 牛顿）转换为优化器喜欢的、无单位且大小在1附近的数值，并在计算完成后再翻译回来。

*   `outer_solver.py`: **[V5.1-总指挥]** 这是逆运动学的最顶层接口。它负责协调其他所有模块，实现了最终版的、物理意义更一致的求解策略。它将“位姿误差”、“弹性力梯度”和“平滑项”组合成一个统一的向量式优化目标。

*   `analysis/`: **[分析脚本目录]** 存放所有用于性能分析（如路径跟踪、敏感性分析、工作空间分析）的脚本。其中 `path_tracking.py` 还实现了**多起点随机搜索**策略，以保证求解的全局最优性。

## 3. 核心工作流程 (V5.1 - 物理一致性求解)

逆运动学求解（从目标位姿 `T_target` 求解驱动力 `τ`）的核心，是通过一套“多起点”+“带翻译”+“全解析”的嵌套优化流程来实现的。这套流程确保了求解的全局性、稳定性、和高效性。

以下是调用一次 `path_tracking.py` 中的路径点求解后，内部发生的故事：

### **步骤 0: 全局探索 (在分析层)**

1.  **广撒网**: `path_tracking.py` 首先会生成`N`个在驱动力可行域内的**随机**初始驱动力 `τ_guess`。
2.  **择优录取**: 它会用每一个 `τ_guess` 去调用 `outer_solver.py`，执行完整的逆运动学求解（步骤1-4），并最终从`N`个结果中，选择那个使得机器人末端位姿误差最小的解，作为当前路径点的最终解。

### **步骤 1: 进入数学世界 (进入“计算特区”)**

1.  **接收物理任务**: `outer_solver.py` 的 `solve_inverse_kinematics` 函数接收到的是一个完全物理的、带SI单位的目标（如目标位姿 `T_target`）和来自步骤0的某一个初始猜测 `τ_guess`。
2.  **请求翻译**: 它首先调用 `nondimensionalizer.py`，计算出当前问题的一系列“特征尺度”。
3.  **完成翻译**: 接着，它使用这些特征尺度，将所有输入，包括驱动力的初始猜测、驱动力的上下限等，都从物理单位“翻译”成无量纲的数值（我们称之为`hat_tau`, `hat_bounds`等）。

### **步骤 2: 在数学世界中求解**

1.  **调用优化器**: `outer_solver.py` 将这些无量纲的、被“净化”过的数据，交给 `scipy.optimize.least_squares` (TRF) 优化器。
2.  **优化器迭代**: `scipy` 开始它的迭代寻优工作。它完全不知道物理世界是什么样的，它只在一个大小都在1.0附近、非常“健康”的数学世界里，不断尝试新的无量纲驱动力 `hat_tau`。
3.  **评估好坏**: `scipy` 每尝试一组新的 `hat_tau`，都会调用我们的**残差函数** `residual_function_nondimensional` 来评估好坏，并调用我们的**雅可比函数** `jacobian_function_nondimensional` 来决定下一步的方向。

### **步骤 3: “同声传译”与“全解析” - 残差与雅可比的桥梁作用**

这是整个系统最精妙的地方。每当`scipy`需要计算残差或雅可比时，内部会立刻执行一次“往返翻译”和“精确计算”：

1.  **“数学”->“物理”**: 将 `hat_tau` **翻译回** 物理世界的驱动力 `τ`。
2.  **调用物理引擎 (内循环)**: 用这个 `τ` 去调用我们已经验证过的 `solver.py`，在真实的物理世界中，计算出机器人实际的平衡构型 `q_eq`。
3.  **计算物理误差**: 在物理世界中，利用 `kinematics.py` 和 `statics.py` 计算V5.1版本的核心优化目标：
    *   **位姿误差**: `T(q_eq)` 和 `T_target` 之间的6维误差向量。
    *   **弹性力梯度**: 在 `q_eq` 点的7维弹性势能梯度 `∇U_elastic`。
    *   **平滑度误差**: 当前 `τ` 与上一步 `τ` 的8维差值向量。
4.  **“物理”->“数学”**: 将上述三个物理误差向量，再次**翻译回**无量纲的数值，并拼接成一个21维的**总残差向量** `hat_error_total`，返回给`scipy`。
5.  **（雅可比计算）**: 当`scipy`需要雅可比时，我们会重复1-2步，然后在该平衡点 `q_eq` 处，调用 `kinematics.py` 和 `statics.py` 中已经实现好的**全套解析函数**，计算出外循环雅可比 `J_outer = -J_kin * H⁻¹ * C`，并将其无量纲化后返回给`scipy`。

通过这个过程，`scipy` 优化器始终在一个它能理解的、健康的数学世界里工作，并且获得了最精确、最稳定的梯度信息，从而实现了高效、鲁棒的求解。

### **步骤 4: 回归物理世界**

1.  **得到数学解**: `scipy` 优化器在数学世界里完成了它的任务，找到了一个最优的无量纲驱动力 `hat_τ*`。
2.  **最终翻译**: `outer_solver.py` 函数拿到这个数学解后，会最后一次调用 `nondimensionalizer.py`，将其**翻译回**带有牛顿（N）单位的、物理世界中的真实驱动力 `τ*`。
3.  **返回物理结果**: 这个 `τ*` 就是我们最终需要的、可以在真实机器人上应用的求解结果。

## 4. 算法逻辑与流程图 (Algorithm Logic and Flowchart)

核心算法逻辑围绕着**嵌套优化**展开，即一个外层优化器（TRF）调用一个内层优化器（L-BFGS-B）。

### 4.1 整体流程概述

整个逆运动学求解过程可以概括为：

1.  **初始化**: 从 `config.json` 加载机器人物理参数，并进行单位换算。
2.  **多起点猜测**: 在驱动力可行域内生成多个随机初始驱动力猜测。
3.  **外循环优化 (TRF)**:
    *   对于每个初始驱动力猜测，启动一个外层优化过程。
    *   外层优化器迭代调整无量纲驱动力 `hat_τ`，以最小化目标残差。
    *   在每次迭代中，将 `hat_τ` 翻译回物理驱动力 `τ`。
    *   **内循环优化 (L-BFGS-B)**: 使用 `τ` 作为输入，求解机器人的平衡构型 `q_eq`。
    *   计算基于 `q_eq` 的物理误差（位姿误差、弹性力梯度、平滑度误差）。
    *   将物理误差翻译回无量纲残差，并返回给外层优化器。
    *   计算并返回解析雅可比矩阵。
4.  **结果筛选**: 从所有多起点优化结果中，选择末端位姿误差最小的解作为最终结果。

### 4.2 流程图 (Flowchart)

由于我无法直接生成图形，以下是核心工作流程的文本描述，您可以根据此描述绘制流程图。

**主流程：逆运动学求解 (Inverse Kinematics Solving)**

```
[开始]
  |
  V
[加载配置参数 (config.json)]
  |
  V
[初始化: 生成 N 个随机初始驱动力猜测 (τ_guess)]
  |
  V
[循环 N 次 (对于每个 τ_guess)]
  |
  V
  [调用 outer_solver.solve_inverse_kinematics(T_target, τ_guess)]
    |
    V
    [步骤 1: 进入数学世界 (nondimensionalizer)]
      |
      V
      [步骤 2: 外循环优化 (scipy.optimize.least_squares - TRF)]
        |
        V
        [迭代: 评估残差函数 (residual_function_nondimensional)]
          |
          V
          [“数学”->“物理”翻译 (hat_τ -> τ)]
            |
            V
            [调用 solver.solve_static_equilibrium(τ)]
              |
              V
              [内循环优化 (scipy.optimize.minimize - L-BFGS-B)]
                |
                V
                [计算平衡构型 q_eq]
                |
                V
                [返回 q_eq]
            |
            V
          [计算物理误差 (位姿误差, 弹性力梯度, 平滑度误差)]
            |
            V
          [“物理”->“数学”翻译 (物理误差 -> hat_error_total)]
            |
            V
          [返回 hat_error_total 给外循环优化器]
          |
          V
        [迭代: 评估雅可比函数 (jacobian_function_nondimensional)]
          |
          V
          [计算解析雅可比 J_outer = -J_kin * H⁻¹ * C]
            |
            V
          [无量纲化 J_outer]
            |
            V
          [返回无量纲化 J_outer 给外循环优化器]
          |
          V
        [外循环优化结束]
          |
          V
        [得到最优无量纲驱动力 hat_τ*]
          |
          V
      [步骤 4: 回归物理世界 (nondimensionalizer)]
        |
        V
      [hat_τ* -> 物理驱动力 τ*]
        |
        V
      [返回 τ*]
    |
    V
  [存储当前 τ* 的结果 (位姿误差)]
  |
  V
[循环结束]
  |
  V
[从所有结果中选择位姿误差最小的 τ* 作为最终解]
  |
  V
[结束]
```

## 5. 验证与诊断 (Verification and Diagnosis)

为了确保模型的准确性和算法的鲁棒性，本项目采用了多层次的验证和诊断策略：

*   **单元测试**: 针对 `kinematics.py`, `statics.py`, `nondimensionalizer.py` 等核心模块，编写了详细的单元测试，验证其数学计算的正确性（例如，解析导数与数值导数的对比）。
*   **集成测试**: 通过 `verification/` 目录下的脚本，验证不同模块协同工作时的正确性，例如 `verify_forward_kinematics.py` 验证正运动学，`verify_physics.py` 验证静力学平衡。
*   **物理可行性检查**: 在优化过程中，对构型向量 `q` 和驱动力 `τ` 的物理可行域进行约束或惩罚，避免出现非物理结果。
*   **路径跟踪回放**: `analysis/path_tracking.py` 不仅用于求解，也用于回放求解结果，通过可视化检查机器人是否能准确跟踪目标路径。
*   **参数敏感性分析**: `analysis/sensitivity_analysis.py` 用于评估模型参数（如刚度）变化对机器人性能（如工作空间充实度）的影响，帮助理解模型行为。
*   **工作空间分析**: `analysis/workspace_analysis.py` 用于生成和分析机器人的工作空间，直观地展示机器人的可达范围。
*   **数值稳定性诊断**: 监控优化器的收敛情况、残差变化、梯度范数等，及时发现数值病态问题。

**可复现实验/脚本**:

*   **运行 `analysis/path_tracking.py`**: 这是最主要的端到端验证脚本，它会执行完整的逆运动学求解过程，并生成路径跟踪的可视化结果。
*   **运行 `verification/derive_and_verify.py`**: 用于验证解析导数的正确性。
*   **运行 `analysis/workspace_analysis.py`**: 用于生成工作空间点云和可视化。

## 6. 边界与风险 (Boundaries and Risks)

### 6.1 边界

*   **机器人结构**: 本项目严格限定于三段式 PCC 混合结构机器人。
*   **驱动方式**: 仅考虑线缆驱动，且线缆布局为短线组（PSS+CMS_Proximal）和长线组（贯穿三段）。
*   **物理模型**: 基于连续体机器人标准模型，考虑弹性、驱动和重力，暂不考虑摩擦、粘滞阻尼、动力学效应等。
*   **优化方法**: 内循环使用 L-BFGS-B，外循环使用 TRF 最小二乘。
*   **单位约定**: 配置文件以 mm 录入，加载后统一换算为 m 进行内部计算。

### 6.2 风险

*   **局部最优**: 尽管采用了多起点随机搜索，但对于非凸优化问题，仍存在陷入局部最优解的风险。
*   **数值病态**: 在某些极端构型或参数组合下，可能出现雅可比矩阵或海森矩阵病态，导致优化器收敛困难或不稳定。
*   **参数敏感性**: 模型的性能可能对某些物理参数（如刚度、线缆预张力）高度敏感，不准确的参数可能导致求解失败或结果不佳。
*   **计算效率**: 嵌套优化和多起点搜索虽然提高了鲁棒性，但也增加了计算负担，对于实时控制可能需要进一步优化。
*   **模型简化**: 物理模型的简化（例如忽略摩擦）可能导致仿真结果与实际机器人行为存在偏差。

**缓解策略**:

*   **多起点与全局搜索**: 增加初始猜测点的数量和多样性。
*   **正则化**: 在残差中加入平滑项 `w(τk−τk−1)` 以抑制驱动力突变，提高优化稳定性。
*   **尺度化**: 无量纲化处理确保优化器在“健康”的数值域工作。
*   **解析导数**: 使用解析梯度和海森矩阵，提高优化精度和速度，减少数值误差。
*   **边界约束**: 对构型和驱动力施加物理可行域约束。
*   **参数辨识**: 未来可考虑引入参数辨识方法，提高模型参数的准确性。

## 7. 下一步 (Next Steps)

*   **实时性优化**: 探索更高效的优化算法或预计算策略，以满足实时控制的需求。
*   **动力学建模**: 引入机器人动力学模型，实现更精确的运动控制。
*   **环境交互**: 考虑机器人与环境的接触和交互，扩展应用场景。
*   **硬件集成**: 将求解器集成到实际机器人硬件平台，进行真实世界验证。
*   **用户界面**: 开发图形用户界面 (GUI)，方便用户进行参数配置、路径规划和结果可视化。
*   **更复杂的驱动方式**: 探索除线缆驱动外的其他驱动方式，如气动、液压等。
*   **多机器人协作**: 扩展到多机器人系统，实现协同操作。
