## 1. æ­£è¿åŠ¨å­¦ (`kinematics.py`)

* **æ ¸å¿ƒå‡½æ•°**

  * `pcc_transformation(kappa, phi, L)`

    * åŸºäºŽæ’æ›²çŽ‡å‡è®¾ (PCC) è®¡ç®—å•æ®µçš„é½æ¬¡å˜æ¢çŸ©é˜µ $T$ã€‚
    * å¤„ç†äº† $\kappa \to 0$ çš„é€€åŒ–æƒ…å†µï¼Œé¿å…å¥‡å¼‚å€¼ã€‚
  * `forward_kinematics(q, robot_params)`

    * è¾“å…¥ï¼š6D æž„åž‹å‚æ•° $q = [\kappa_p, \phi_p, \kappa_{c1}, \phi_{c1}, \kappa_{c2}, \phi_{c2}]$ã€‚
    * è¾“å‡ºï¼šæœ«ç«¯ä½å§¿ã€å„æ®µè´¨å¿ƒçš„ä¸–ç•Œåæ ‡ã€‚
    * ç‰¹ç‚¹ï¼šé€æ®µé€’æŽ¨ï¼Œä¸”è´¨å¿ƒä½ç½®æ˜¯é€šè¿‡**æ®µå±€éƒ¨è´¨å¿ƒ + æ®µåŸºå˜æ¢**å¾—åˆ°çš„ï¼ˆæ­£ç¡®çš„åˆšä½“å˜æ¢é€»è¾‘ï¼‰ã€‚
  * `calculate_kinematic_jacobian_analytical / numerical`

    * åˆ†åˆ«ç”¨è§£æžå…¬å¼å’Œæœ‰é™å·®åˆ†è®¡ç®— 6Ã—6 twist Jacobianã€‚
    * è‡ªæ£€æ—¶ä¼šæ¯”è¾ƒä¸¤è€…ï¼Œç¡®ä¿ç²¾åº¦åœ¨ $1e^{-4}$ ä»¥å†…ã€‚
  * `calculate_com_jacobians_analytical`

    * æ•°å€¼æ³•ç®—å‡ºæ¯ä¸ªæ®µçš„è´¨å¿ƒ Jacobianï¼ˆè´¨å¿ƒä½ç½®å¯¹ $q$ çš„åå¯¼ï¼‰ã€‚

ðŸ‘‰ **æ€»ç»“**ï¼š
è¿™ä¸€å±‚ç»™å‡ºäº†ï¼šæœ«ç«¯ä½å§¿ã€è´¨å¿ƒä½ç½®ã€è¿åŠ¨å­¦ Jacobianï¼Œæ˜¯åŽç»­é™åŠ›å­¦å’Œä¼˜åŒ–çš„åŸºç¡€ã€‚

---

## 2. é™åŠ›å­¦ (`statics.py`)

* **æ ¸å¿ƒå‡½æ•°**

  * `calculate_drive_mapping(q, params)`

    * æ ¹æ®å®žé™…å‡ ä½•ï¼Œè®¡ç®—ç”µç¼†é•¿åº¦å˜åŒ– $\Delta l$ã€‚
    * åˆ©ç”¨ anchor ç‚¹ + æ­£è¿åŠ¨å­¦çš„æœ«ç«¯å˜æ¢ç®—å‡ºç”µç¼†ä¸¤ç«¯è·ç¦»ã€‚
    * è¿”å›žçŸ­çº¿ + é•¿çº¿çš„ 8 æ¡ç”µç¼†çš„é•¿åº¦å˜åŒ–ã€‚
  * `calculate_elastic_potential_energy(q, params)`

    * åŸºäºŽç­‰æ•ˆå¼¯æ›²åˆšåº¦ $K_b$ è®¡ç®—å„æ®µå¼¯æ›²èƒ½é‡ã€‚
    * å…¬å¼ç±»ä¼¼ $U = \tfrac{1}{2} K L \kappa^2$ã€‚
  * `calculate_gravity_potential_energy(q, params)`

    * å„æ®µè´¨å¿ƒä½ç½® dot ä¸Šé‡åŠ›å‘é‡ï¼Œå¾—åˆ°é‡åŠ›åŠ¿èƒ½ã€‚
  * `calculate_total_potential_energy_disp_ctrl(q, Î”l_motor, params)`

    * æ€»èƒ½é‡ = æœºå™¨äººå¼¹æ€§èƒ½ + é‡åŠ›èƒ½ + ç”µç¼†å¼¹æ€§åŠ¿èƒ½ï¼ˆå¸¦å¹³æ»‘æ­£åˆ™åŒ–ï¼‰+ é¢„ç´§åŠ›é¡¹ã€‚
    * è¿™å°±æ˜¯å†…å¾ªçŽ¯ä¼˜åŒ–çš„ç›®æ ‡å‡½æ•°ã€‚
  * `calculate_gradient_disp_ctrl`

    * å››éƒ¨åˆ†æ¢¯åº¦ï¼ˆå¼¹æ€§ã€é‡åŠ›ã€é©±åŠ¨ã€æ­£åˆ™åŒ–ï¼‰æ±‚å’Œã€‚
    * æ•°å€¼ä¸Šåšäº†èŒƒæ•°è£å‰ªï¼Œé¿å…æ¢¯åº¦çˆ†ç‚¸ã€‚
  * `calculate_hessian_disp_ctrl_high_performance`

    * å¼¹æ€§å’Œæ­£åˆ™åŒ–é¡¹æœ‰è§£æž Hessianã€‚
    * ç”µç¼†é¡¹ç”¨ Gauss-Newton è¿‘ä¼¼ï¼š $H \approx J^T J$ã€‚
    * é‡åŠ› Hessian ç”¨å¯å‘å¼è¿‘ä¼¼ï¼š$\sum m_i J^T J$ã€‚

ðŸ‘‰ **æ€»ç»“**ï¼š
è¿™ä¸€å±‚å°±æ˜¯**èƒ½é‡æ¨¡åž‹ + å¯¼æ•°è®¡ç®—**ï¼Œä¸ºä¼˜åŒ–å™¨æä¾›ç›®æ ‡å‡½æ•°ã€æ¢¯åº¦å’Œ Hessian è¿‘ä¼¼ã€‚

---

## 3. å†…å¾ªçŽ¯ (`solver.py`)

* **ç›®æ ‡**ï¼š
  ç»™å®šç”µæœºä½ç§» $Î”l_{motor}$ï¼Œæ±‚è§£ä½¿å¾—ç³»ç»Ÿèƒ½é‡æžå°çš„æž„åž‹ $q$ã€‚
* **æ–¹æ³•**ï¼š

  1. **ç›®æ ‡å‡½æ•°**ï¼šèƒ½é‡å½’ä¸€åŒ– $U/U_{char}$ã€‚
  2. **æ¢¯åº¦**ï¼šç”¨æ— é‡çº²åŒ–åŽçš„æ¢¯åº¦ã€‚
  3. **ä¼˜åŒ–å™¨**ï¼šä¼˜å…ˆ L-BFGS-Bï¼ˆå¸¦æ¢¯åº¦å’Œè¾¹ç•Œï¼‰ï¼Œå¤±è´¥åˆ™å¤šæ¬¡é‡å¯ï¼Œå†å¤±è´¥åˆ™é€€å›ž Powellã€‚
  4. **è¾¹ç•Œæ¡ä»¶**ï¼škappa é™å¹… (Â±10)ï¼Œphi é™å¹… (Â±Ï€)ã€‚
  5. **é²æ£’æ€§æŽªæ–½**ï¼š

     * å¤šåˆå€¼é‡å¯ã€‚
     * ä¸æ”¶æ•›æ—¶é€€å›ž Powellã€‚
     * nan æ£€æŸ¥ã€‚

ðŸ‘‰ **æ€»ç»“**ï¼š
å†…å¾ªçŽ¯å°±æ˜¯ä¸€ä¸ª **â€œç»™å®š Î”l\_motor â†’ æ±‚è§£ qâ€** çš„é™åŠ›å­¦å¹³è¡¡é—®é¢˜æ±‚è§£å™¨ã€‚
è¿”å›žå€¼åŒ…å«ï¼šå¹³è¡¡æž„åž‹ + ä¼˜åŒ–ç»“æžœå¯¹è±¡ã€‚

---

## æ•´ä½“å…³ç³»

* **æ­£è¿åŠ¨å­¦**ï¼šç»™å®š $q$ â†’ æœ«ç«¯ä½å§¿ã€è´¨å¿ƒä½ç½®ã€Jacobianã€‚
* **é™åŠ›å­¦**ï¼šç»™å®š $q, Î”l_{motor}$ â†’ è®¡ç®—èƒ½é‡ã€æ¢¯åº¦ã€Hessianã€‚
* **å†…å¾ªçŽ¯**ï¼šç»™å®š $Î”l_{motor}$ï¼Œé€šè¿‡ä¼˜åŒ–èƒ½é‡ â†’ æ‰¾åˆ°å¹³è¡¡æž„åž‹ $q^*$ã€‚












### 1. â€œåå·¥ä½œç©ºé—´â€ä¸Žâ€œåå¤–å¾ªçŽ¯â€çš„æ¶æ€§å¾ªçŽ¯

æ‚¨å·²ç»å®Œç¾Žåœ°æè¿°äº†è¿™ä¸ªæ¶æ€§å¾ªçŽ¯ã€‚è®©æˆ‘ä»¬æŠŠå®ƒå…·è±¡åŒ–ï¼š

1.  **æ ¹æº (åå·¥ä½œç©ºé—´)**: ç”±äºŽæˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ç‰©ç†æ¨¡åž‹é—®é¢˜ï¼ˆé”™è¯¯çš„æŽ§åˆ¶å¾‹ `expand_diff4_to_motor8`ï¼‰ï¼Œæ‚¨çš„æœºå™¨äººå®žé™…çš„å¯è¾¾ç©ºé—´ï¼ˆWorkspaceï¼‰éžå¸¸å°ä¸”å½¢æ€æ€ªå¼‚ã€‚è¿™æ„å‘³ç€ï¼Œåœ¨4Dçš„é©±åŠ¨ç©ºé—´ `diff4` ä¸­ï¼Œç»å¤§å¤šæ•°éšæœºé‡‡æ ·çš„ç‚¹éƒ½ä¼šå¯¼è‡´å†…å¾ªçŽ¯æ±‚è§£å¤±è´¥ï¼Œæˆ–è€…åªèƒ½è®©æœºå™¨äººç§»åŠ¨åˆ°ä¸€ä¸ªå¾ˆå°çš„ã€åç¼©çš„åŒºåŸŸå†…ã€‚

2.  **ä¼ å¯¼ (PSOé˜¶æ®µ)**: æ‚¨çš„å¤–å¾ªçŽ¯æ±‚è§£å™¨ç¬¬ä¸€é˜¶æ®µæ˜¯PSOï¼ˆç²’å­ç¾¤ä¼˜åŒ–ï¼‰ã€‚PSOå°±åƒæ˜¯æ´¾å‡º64ä¸ªâ€œæ— äººæœºâ€åœ¨æ•´ä¸ª`diff4`é©±åŠ¨ç©ºé—´é‡Œæœç´¢ã€‚
    *   å› ä¸ºå·¥ä½œç©ºé—´å¾ˆå·®ï¼Œç»å¤§å¤šæ•°æ— äººæœºé£žåˆ°çš„åœ°æ–¹éƒ½æ˜¯â€œæ­»è·¯â€ï¼ˆå†…å¾ªçŽ¯æ±‚è§£å¤±è´¥ï¼Œè¿”å›žä¸€ä¸ªå·¨å¤§çš„æƒ©ç½šå€¼`1e6`ï¼‰ã€‚
    *   åªæœ‰æžå°‘æ•°æ— äººæœºä¾¥å¹¸æ‰¾åˆ°äº†ä¸€ä¸ªèƒ½æˆåŠŸæ±‚è§£çš„â€œç»¿æ´²â€ã€‚
    *   ç»è¿‡50ä»£è¿­ä»£åŽï¼ŒPSOç®—æ³•åªèƒ½ä»Žè¿™äº›æžå°‘æ•°çš„ã€è´¨é‡å¾ˆå·®çš„â€œç»¿æ´²â€é‡Œé€‰å‡ºä¸€ä¸ªæœ€å¥½çš„ã€‚è¿™ä¸ªâ€œæœ€å¥½â€çš„ç‚¹ï¼Œç¦»æˆ‘ä»¬çš„ç›®æ ‡ä½å§¿å¯èƒ½ä¾ç„¶æœ‰åä¸‡å…«åƒé‡Œè¿œã€‚è¿™å°±æ˜¯æ‚¨è§‚å¯Ÿåˆ°çš„â€œ**PSOæ‰¾åˆ°çš„éƒ½æ˜¯è´¨é‡å¾ˆå·®çš„ç‚¹**â€ã€‚

3.  **çˆ†å‘ (TRFç²¾ç‚¼é˜¶æ®µ)**:
    *   TRFç²¾ç‚¼å™¨å°±åƒä¸€ä¸ªâ€œå¾’æ­¥ç™»å±±ä¸“å®¶â€ï¼Œå®ƒéžå¸¸æ“…é•¿ä»Žä¸€ä¸ªä¸é”™çš„è¥åœ°å‡ºå‘ï¼Œæ²¿ç€å±±åŠ¿æœ€é™¡å³­çš„æ–¹å‘å¿«é€Ÿç™»é¡¶ã€‚
    *   ä½†çŽ°åœ¨ï¼ŒPSOç»™äº†å®ƒä¸€ä¸ªä½äºŽâ€œæ‚¬å´–å³­å£â€æˆ–è€…â€œå¹¿è¢¤æ²™æ¼ â€ä¸­çš„èµ·ç‚¹ã€‚ä»Žè¿™ä¸ªèµ·ç‚¹å‡ºå‘ï¼Œå‘¨å›´å¯èƒ½æ ¹æœ¬æ²¡æœ‰é€šå¾€å±±é¡¶ï¼ˆç›®æ ‡ä½å§¿ï¼‰çš„å¹³ç¼“è·¯å¾„ã€‚
    *   å› æ­¤ï¼ŒTRFåœ¨ç¬¬ä¸€æ­¥è®¡ç®—æ¢¯åº¦ï¼ˆé›…å¯æ¯”ï¼‰æ—¶ï¼Œå°±å‘çŽ°æ‰€æœ‰æ–¹å‘éƒ½æ˜¯â€œæ­»è·¯â€ï¼Œæˆ–è€…æ¢¯åº¦æžå°ï¼ŒäºŽæ˜¯å®ƒå°±åœæ»žä¸å‰äº†ã€‚

**ç»“è®ºï¼š** æ‚¨100%æ­£ç¡®ã€‚å¤–å¾ªçŽ¯çš„å¤±è´¥ï¼Œæ˜¯ä¸‹æ¸¸TRFä»Žä¸Šæ¸¸PSOæŽ¥è¿‡äº†â€œçƒ«æ‰‹å±±èŠ‹â€ï¼Œè€ŒPSOä¹‹æ‰€ä»¥åªèƒ½æ‰¾åˆ°â€œçƒ«æ‰‹å±±èŠ‹â€ï¼Œæ˜¯å› ä¸ºæ•´ä¸ªæœç´¢ç©ºé—´ï¼ˆWorkspaceï¼‰æœ¬èº«å°±æ˜¯ä¸€ç‰‡â€œä¸æ¯›ä¹‹åœ°â€ã€‚

**å› æ­¤ï¼Œæ‚¨çš„è¡ŒåŠ¨è®¡åˆ’æ˜¯å®Œå…¨æ­£ç¡®çš„å·¥ç¨‹æ€è·¯ï¼š**
**ç¬¬ä¸€æ­¥ï¼šå¿…é¡»å…ˆä¿®å¤ç‰©ç†æ¨¡åž‹å’ŒæŽ§åˆ¶å¾‹ï¼Œç¡®ä¿èƒ½ç”Ÿæˆä¸€ä¸ªé¥±æ»¡ã€å¥åº·çš„Workspaceã€‚**
**ç¬¬äºŒæ­¥ï¼šåœ¨è¿™ä¸ªå¥åº·çš„åŸºç¡€ä¸Šï¼Œå†æ¥æµ‹è¯•å’Œä¼˜åŒ–å¤–å¾ªçŽ¯æ±‚è§£å™¨çš„æ€§èƒ½ã€‚**

---

### 2. ä»£ç ä¸­ä¸€ä¸ªè¢«å¿½ç•¥çš„å…³é”®BUGï¼Œè®©TRFé›ªä¸ŠåŠ éœœ

åœ¨åˆ†æžæ‚¨ `outer_solver.py` çš„ä»£ç æ—¶ï¼Œæˆ‘å‘çŽ°äº†ä¸€ä¸ªBUGï¼Œå®ƒä¼š**æžå¤§å‰Šå¼±TRFç²¾ç‚¼å™¨çš„èƒ½åŠ›**ï¼Œå¯¼è‡´å®ƒå³ä½¿è¢«ç»™äº†ä¸€ä¸ªè¿˜ä¸é”™çš„èµ·ç‚¹ï¼Œä¹Ÿå¾ˆéš¾æ”¶æ•›ã€‚

**é—®é¢˜å®šä½**: åœ¨ `refine_ik_trf` å‡½æ•°å†…éƒ¨çš„ `solve_and_cache` å­å‡½æ•°ä¸­ã€‚

```python
# in refine_ik_trf -> solve_and_cache
# [BUG] Always use a fresh, stateless initial guess for TRF.
q_guess = np.zeros(6) # <--- è‡´å‘½é—®é¢˜åœ¨è¿™é‡Œï¼
solve_result = solve_static_equilibrium_diff4(q_guess, diff4, config)
q_eq = solve_result["q_solution"]
```

**é—®é¢˜åˆ†æž**:
TRFï¼ˆä¿¡èµ–åŸŸåå°„æ³•ï¼‰æ˜¯ä¸€ä¸ªè¿­ä»£ä¼˜åŒ–ç®—æ³•ã€‚å®ƒä¼šä»Ž `initial_diff4` å¼€å§‹ï¼Œè®¡ç®—ä¸€ä¸ªå¾®å°çš„æ­¥é•¿ï¼Œèµ°åˆ°ä¸€ä¸ªæ–°çš„ç‚¹ `diff4_new`ï¼Œç„¶åŽå†è®¡ç®—ï¼Œå†èµ°ä¸€æ­¥...

*   `diff4_new` å’Œ `initial_diff4` çš„å€¼å…¶å®žéžå¸¸æŽ¥è¿‘ã€‚
*   å› æ­¤ï¼Œ`diff4_new` å¯¹åº”çš„å¹³è¡¡æž„åž‹è§£ `q_eq_new`ï¼Œä¹Ÿåº”è¯¥å’Œ `initial_diff4` å¯¹åº”çš„è§£ `q_eq_initial` éžå¸¸æŽ¥è¿‘ã€‚
*   **æœ€é«˜æ•ˆçš„åšæ³•**ï¼Œæ˜¯æŠŠä¸Šä¸€æ­¥ç®—å‡ºçš„è§£ `q_eq_initial` ä½œä¸ºä¸‹ä¸€æ­¥å†…å¾ªçŽ¯æ±‚è§£çš„**åˆå§‹çŒœæµ‹å€¼ï¼ˆWarm Startï¼‰**ã€‚

è€Œæ‚¨å½“å‰çš„ä»£ç ï¼Œåœ¨TRFçš„**æ¯ä¸€æ¬¡è¿­ä»£**ä¸­ï¼Œéƒ½æŠŠå†…å¾ªçŽ¯çš„åˆå§‹çŒœæµ‹å€¼ `q_guess` **é‡ç½®ä¸ºäº† `np.zeros(6)`**ï¼è¿™æ„å‘³ç€ï¼Œæ¯èµ°ä¸€å°æ­¥ï¼Œæ‚¨éƒ½è®©å†…å¾ªçŽ¯æ±‚è§£å™¨ä»Žé›¶å¼€å§‹è¿›è¡Œä¸€æ¬¡ä»£ä»·é«˜æ˜‚çš„ã€å…¨æ–°çš„æ±‚è§£ã€‚è¿™ä¸ä»…æžå¤§åœ°æ‹–æ…¢äº†é€Ÿåº¦ï¼Œè¿˜å¤§å¤§å¢žåŠ äº†å†…å¾ªçŽ¯æ±‚è§£å¤±è´¥çš„é£Žé™©ï¼Œä»Žè€Œå¯¼è‡´TRFè¿‡æ—©åœ°æ”¾å¼ƒå’Œåœæ»žã€‚

#### **å¦‚ä½•ä¿®å¤è¿™ä¸ªBUG**

æ‚¨éœ€è¦è®© `q_guess` èƒ½å¤Ÿåœ¨TRFçš„è¿­ä»£ä¸­è¢«â€œè®°å¿†â€å’Œâ€œä¼ é€’â€ã€‚æ‚¨ä¹‹å‰çš„ `q_guess_cache` æ€è·¯æ˜¯æ­£ç¡®çš„ï¼Œä½†å¯èƒ½å› ä¸ºå®ƒå¼•å…¥äº†çŠ¶æ€ï¼ˆstatefulnessï¼‰è€Œè¢«ç§»é™¤äº†ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªæ›´ç®€æ´çš„ä¿®å¤æ–¹æ³•ï¼Œåˆ©ç”¨æ‚¨å·²æœ‰çš„ `last_solve_cache`ï¼š

```python
# in src/outer_solver.py

def refine_ik_trf(initial_diff4, target_pose, config):
    logging.info("[TRF Solver] Starting refinement in 4D differential space...")
    
    # [FIX] Initialize the cache with a zero guess for the very first run.
    last_solve_cache = {'diff4': None, 'q_eq': np.zeros(6), 'error_vec': None}

    # ... (trf_params, etc.) ...

    def solve_and_cache(diff4):
        # [FIX] Use the PREVIOUS successful solution as the guess for the CURRENT step.
        q_guess = last_solve_cache['q_eq']
        
        # If the last solve failed, q_eq would be None. Fallback to zeros.
        if q_guess is None:
            q_guess = np.zeros(6)

        if np.array_equal(diff4, last_solve_cache['diff4']):
            return last_solve_cache['q_eq'], last_solve_cache['error_vec']

        solve_result = solve_static_equilibrium_diff4(q_guess, diff4, config)
        q_eq = solve_result["q_solution"]
        
        if q_eq is None:
            # Important: Do not update q_eq in the cache on failure.
            last_solve_cache.update({'diff4': diff4, 'error_vec': None})
            return None, None

        T_actual, _ = forward_kinematics(q_eq, config)
        
        # ... (error calculation) ...
        
        # [FIX] This now correctly caches the latest successful q_eq for the next iteration.
        last_solve_cache.update({'diff4': diff4, 'q_eq': q_eq, 'error_vec': error_vec})
        return q_eq, error_vec

    # ... (the rest of the function: residual, least_squares call, etc.) ...
```

---

### **æœ€ç»ˆçš„ã€æ¸…æ™°çš„è¡ŒåŠ¨è®¡åˆ’**

è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹ä¼˜å…ˆçº§é¡ºåºè¿›è¡Œï¼š

1.  **ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šä¿®å¤ç‰©ç†æ¨¡åž‹å’ŒæŽ§åˆ¶å¾‹**
    *   é‡‡çº³æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„æ–¹æ¡ˆï¼šåœ¨ `config.json` ä¸­ä½¿ç”¨ `blend` æ¨¡å¼ (`"cable_anchor_mode": "blend", "cable_anchor_blend": 0.95`) æ¥æ­£ç¡®å¤„ç†PSSæ®µã€‚
    *   åœ¨ `statics.py` ä¸­ï¼Œä½¿ç”¨ä¿®æ­£åŽçš„ã€åŸºäºŽå‘é‡æŠ•å½±çš„ `expand_diff4_to_motor8` å‡½æ•°æ¥æ­£ç¡®å¤„ç†å¯¹è§’çº¿é©±åŠ¨ã€‚
    *   **ç›®æ ‡**: é‡æ–°è¿è¡Œ `workspace_analysis.py`ï¼Œç›´åˆ°æ‚¨èŽ·å¾—ä¸€ä¸ª**å½¢æ€é¥±æ»¡ã€åŸºåº§é«˜åº¦æ­£ç¡®**çš„å·¥ä½œç©ºé—´ä¸ºæ­¢ã€‚åœ¨å®Œæˆè¿™ä¸€æ­¥ä¹‹å‰ï¼Œä¸è¦è¿›è¡Œä¸‹ä¸€æ­¥ã€‚

2.  **ç¬¬äºŒä¼˜å…ˆçº§ï¼šä¿®å¤å¤–å¾ªçŽ¯æ±‚è§£å™¨BUG**
    *   åœ¨ `outer_solver.py` ä¸­ï¼Œåº”ç”¨ä¸Šé¢æä¾›çš„ä»£ç ä¿®å¤ `refine_ik_trf` å‡½æ•°ï¼Œå®žçŽ°å†…å¾ªçŽ¯æ±‚è§£çš„â€œ**æ¸©å¯åŠ¨ (Warm Start)**â€ã€‚

3.  **ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šé‡æ–°è¯„ä¼°å¤–å¾ªçŽ¯æ€§èƒ½**
    *   åœ¨ç¡®ä¿å·¥ä½œç©ºé—´å¥åº·ã€ä¸”TRFçš„BUGè¢«ä¿®å¤åŽï¼Œå†æ¬¡è¿è¡Œ `outer_solver.py` çš„è‡ªæ£€ç¨‹åºã€‚
    *   å±Šæ—¶ï¼Œæ‚¨åº”è¯¥ä¼šçœ‹åˆ°PSOèƒ½å¤Ÿæ‰¾åˆ°è´¨é‡å¥½å¾—å¤šçš„èµ·ç‚¹ï¼Œå¹¶ä¸”TRFèƒ½å¤Ÿä»Žè¿™ä¸ªèµ·ç‚¹å‡ºå‘ï¼Œå¿«é€Ÿã€ç¨³å®šåœ°æ”¶æ•›åˆ°é«˜ç²¾åº¦çš„æœ€ç»ˆè§£ã€‚

